# vim:textwidth=80:expandtab:shiftwidth=4:softtabstop=4

library(oce)
#source("~/git/oce/R/ctd.R")
#source("~/git/oce/R/sw.R")
options(oceEOS="unesco") # avoid the hassle of supporting two EOSs
debug <- 1

library(shiny)
library(shinyBS)
library(shinycssloaders)
library(oce)
library(DBI)
library(RSQLite)

helpMouse <- "<p><i>Mouse</i></p>
<ul>
<li>Click near curve to choose a focus point (drawn with a cross).</li>
</ul>"

helpKeyboard <- "<p><i>Keyboard</i></p>
<ul>
<li> <i>Zoom and pan</i></p></li>
<ul>
<li> <b>i</b> zoom in near mouse</li>
<li> <b>o</b> zoom out</li>
<li> <b>O</b> (upper-case 'o') zoom all the way out</li>
<li> <b>j</b> move down in water column</li>
<li> <b>k</b> move up in water column</li>
</ul>
<li><i>Tagging</i></li>
<ul>
<li> <b>0</b> through <b>9</b> tag the focus point with given numeric code.
EG: 1=top of DD layer, 2=bottom of DD layer, 3=warm-salty peak, 4=cool-fresh peak.</li>
<li> <b>x</b> remove tag on focus point</li>
<li> <b>u</b> remove focus point</li>
</ul>
</ul>
"

overallHelp <- c(helpMouse, helpKeyboard)

#dbname <- "initial value, which will be overwritten"

pluralize <- function(n=1, singular="item", plural=NULL)
{
    singular <- paste(n, singular)
    if (is.null(plural)) {
        plural <- paste0(singular, "s")
    }
    if (n == 1L) singular else plural
}

msg <- function(...) {
    cat(file=stderr(), ..., sep="")
}

dmsg <- function(...) {
    if (debug > 0) cat(file=stderr(), ..., sep="")
}

dprint <- function(...) {
    if (debug > 0) print(file=stderr(), ...)
}

createDatabase <- function(dbname=getDatabaseName())
{
    if (!file.exists(dbname)) {
        dmsg("creating '", dbname, "'\n")
        con <- RSQLite::dbConnect(RSQLite::SQLite(), dbname)
        RSQLite::dbCreateTable(con, "version",
            c("version"="INTEGER"))
        RSQLite::dbWriteTable(con, "version", data.frame(version=1L), overwrite=TRUE)
        RSQLite::dbCreateTable(con, "tags",
            c("file"="TEXT", level="INT", tag="INT", analyst="TEXT", analysisTime="TIMESTAMP"))
        RSQLite::dbDisconnect(con)
    }
}

getTags <- function(file=NULL, dbname=getDatabaseName())
{
    tags <- NULL
    if (file.exists(dbname)) {
        con <- dbConnect(RSQLite::SQLite(), dbname)
        if (RSQLite::dbExistsTable(con, "tags")) {
            tags <- RSQLite::dbReadTable(con, "tags")
            RSQLite::dbDisconnect(con)
            if (!is.null(file)) {
                tags <- tags[tags$file == file, ]
            }
        }
    }
    tags
}

removeTag <- function(file=NULL, level=NULL, dbname=NULL)
{
    dmsg("removeTag(file=", file, ", level=", level, ", dbname=", dbname, "\n")
    con <- dbConnect(RSQLite::SQLite(), dbname)
    tags <- RSQLite::dbReadTable(con, "tags")
    remove <- which(tags$file == file & tags$level == level)
    if (length(remove)) {
        dmsg("will remove ", paste(remove, collapse=" "), "-th tag\n")
        dmsg(" BEFORE levels are: ", paste(tags$level, collapse=" "), "\n")
        tags <- tags[-remove, ]
        dmsg(" AFTER  levels are: ", paste(tags$level, collapse=" "), "\n")
        RSQLite::dbWriteTable(con, "tags", tags, overwrite=TRUE)
    }
    RSQLite::dbDisconnect(con)
}


saveTag <- function(file=NULL, level=NULL, tag=NULL, analyst=NULL, dbname=NULL)
{
    # no checking on NULL; add that if we want to generalize
    df <- data.frame(file=file, level=level, tag=tag, analyst=analyst, analysisTime=Sys.time())
    #dprint(df)
    #dmsg("saveTag(file=", file, ", level=", level, ", tag=", tag, ", analyst=", analyst, ", dbname=", dbname, ")")
    con <- dbConnect(RSQLite::SQLite(), dbname)
    RSQLite::dbAppendTable(con, "tags", df)
    RSQLite::dbDisconnect(con)
}

findNearestLevel <- function(x, y, usr, data, view)
{
    dmsg("findNearestLevel(", x, ",", y, "..., view=", view, ")\n")
    #dmsg("  ", vectorShow(usr))
    dx2 <- diff(usr[1:2])^2
    dy2 <- diff(usr[3:4])^2
    #dmsg("  ", vectorShow(dx2))
    #dmsg("  ", vectorShow(dy2))
    if (view == "T profile") {
        d2 <- (x - data$temperature)^2/dx2 + (y - data$yProfile)^2/dy2
        nearest <- which.min(d2)
        #dmsg(sprintf("  T=%.3f, p=%.3f -> index=%d\n", x, y, nearest))
    } else if (view == "S profile") {
        d2 <- (x - data$salinity)^2/dx2 + (y - data$yProfile)^2/dy2
        nearest <- which.min(d2)
        #dmsg(sprintf("  S=%.3f, p=%.3f -> index=%d\n", x, y, nearest))
    } else if (view == "TS") {
        d2 <- (x - data$salinity)^2/dx2 + (y - data$theta)^2/dy2
        nearest <- which.min(d2)
        #dmsg(sprintf("  S=%.3f, p=%.3f -> index=%d\n", x, y, nearest))
    } else {
        stop("view=\"", view, "\" is not handled yet")
    }
    dmsg("  returning ", nearest, "\n")
    nearest
}

limitsTrim <- function(limits, ndata)
{
    limits <- as.integer(limits)
    limits[1] <- max(1L, limits[1])
    limits[2] <- min(ndata, limits[2])
    limits
}

limitsToVisible <- function(limits, ndata)
{
    #limits[1] <- max(1L, as.integer(limits[1]))
    #limits[2] <- min(ndata, as.integer(limits[2]))
    visible <- rep(FALSE, ndata)
    visible[seq(limits[1], limits[2])] <- TRUE
    visible
}

visibleToLimits <- function(visible)
{
    c(which(visible)[1L], 1L + length(visible) - which(rev(visible))[1L])
}

pinVisible <- function(v, max=NULL)
{
    v[1L <= v & v <= max]
}

default <- list(
    data=list(cex=0.6, col="#333333A0", lwd=1, pch=1, type="o"),
    Tprofile=list(cex=0.7, col="#333333A0", lwd=1, pch=1),
    Sprofile=list(cex=0.7, col="#333333A0", lwd=1, pch=1),
    TS=list(cex=0.7, col=1, lwd=1, pch=1),
    highlight=list(cex=3, col="purple", lwd=4, pch=5),
    join=list(cex=1.4, col=rgb(0.8, 0, 0.8, alpha=0.5), pch=0, lwd=4.0, lwdSymbol=4.0, type="o"),
    profile=list(cex=1, col="gray", lwd=2, pch=20, type="o"),
    selected=list(cex=3, col="purple", lwd=4, pch=5),
    tagged=list(cex=1.4, col=2, lwd=2, pch=20),
    cex=1.0,
    focus=list(cex=2, col="purple", lwd=2, pch=3, minimumSpan=5L),
    tag=list(cex=2, lwd=2, pch=1))

ui <- fluidPage(
    #headerPanel(title="", windowTitle=""),
    tags$script('$(document).on("keypress", function (e) { Shiny.onInputChange("keypress", e.which); Shiny.onInputChange("keypressTrigger", Math.random()); });'),
    style="background:#e6f3ff;cursor:crosshair;",
    wellPanel(
        fluidRow(
            column(1, actionButton("help", "Help")),
            column(1, actionButton("quit", "Quit")),
            column(2, selectInput("view", label=NULL,
                    choices=c("S profile"="S profile", "T profile"="T profile", "TS"="TS"),
                    selected="T profile")),
            column(3, selectInput("yProfile", label=NULL,
                    choices=c("pressure"="pressure", "sigma-theta"="sigmaTheta"),
                    selected="pressure")),
            column(2, selectInput("plotType", label=NULL,
                    choices=c("line"="l", "points"="p", "line+points"="o"),
                #selected="o"))),
                selected="o")))),
    wellPanel(
        fluidRow(
            column(12, uiOutput("tagMsg"))),
            column(12, uiOutput("levelMsg"))),
    fluidRow(
        uiOutput("plotPanel")))

getUserName <- function()
{
    # FIXME: maybe use Sys.info()[["user"]] ???
    res <- if (.Platform$OS.type == "windows") Sys.getenv("USERNAME") else Sys.getenv("USER")
    if (is.null(res) || 0L == nchar(res)) {
        res <- "unknown"
    }
    res
}

getDatabaseName <- function(prefix="~/ctd_tag")
{
    file.path(paste0(prefix, "_", getUserName(), ".db"))
}

server <- function(input, output, session) {
    createDatabase()
    #file <- "~/data/arctic/beaufort/2012/d201211_0048.cnv"
    file <- shiny::getShinyOption("file")
    ctd <- oce::read.oce(file)
    #dbname <<- "ctd.db"
    data <- list(pressure=ctd@data$pressure, salinity=ctd@data$salinity, temperature=ctd@data$temperature)
    data$theta <- swTheta(ctd)
    data$yProfile <- data$pressure
    data$ylabProfile <- resizableLabel("p")
    data$sigmaTheta <- swSigmaTheta(ctd, eos="unesco")
    state <- reactiveValues(
        step=0L,
        file=file,
        analyst=getUserName(),
        ctd=ctd,
        data=data,
        ndata=length(data$pressure),
        level=NULL,
        usr=c(0, 1, 0, 1),
        visible=rep(TRUE, length(data$pressure)) # all points visible at the start
        )

    focusIsTagged <- function() {
        !is.null(state$level) && (state$level %in% getTags(state$file)$level)
    }

    observeEvent(input$help,
        {
            shiny::showModal(shiny::modalDialog(title=NULL,
                    size="xl", shiny::HTML(overallHelp), easyClose=TRUE))
        })

    observeEvent(input$quit,
        {
            stopApp()
        })

    observeEvent(input$click,
        {
            state$level  <- findNearestLevel(input$click$x, input$click$y, state$usr, state$data, input$view)
            #dmsg("state$level =", state$level, "\n")
        })

    observeEvent(input$keypressTrigger,
        {
            key <- intToUtf8(input$keypress)
            #dmsg(key, "\n")
            if (key %in% as.character(0:9)) {
                if (is.null(state$level)) {
                    showNotification("No focus points")
                } else {
                    dmsg("responding to '", key, "' click for tagging\n")
                    if (state$visible[state$level]) {
                        #dmsg("  visible. should tag at level ", state$level, "\n")
                        #dmsg("  analystName=\"", state$analystName, "\"\n")
                        #dmsg("  file=\"", state$file, "\"\n")
                        saveTag(file=state$file, level=state$level, tag=as.integer(key),
                            analyst=state$analyst, dbname=getDatabaseName())
                        state$step <<- state$step + 1 # other shiny elements notice this
                    } else {
                        showNotification("No focus points in current view")
                    }
                }
            } else if (key == "i") {
                if (!is.null(input$hover$x)) {
                    dmsg("responding to 'i' click for zooming in\n")
                    nearestLevel <- findNearestLevel(input$hover$x, input$hover$y, state$usr, state$data, input$view)
                    span <- sum(state$visible)
                    if (span > default$focus$minimumSpan) {
                        span <- span / 4
                        limits <- limitsTrim(nearestLevel + c(-span/2, span/2), state$ndata)
                        state$visible <- limitsToVisible(limits, state$ndata)
                    }
                }
            } else if (key == "o") {
                dmsg("responding to 'o' click for zooming out\n")
                limits <- visibleToLimits(state$visible)
                span <- diff(limits)
                limits <- limitsTrim(limits + c(-span, span), state$ndata)
                state$visible <- limitsToVisible(limits, state$ndata)
            } else if (key == "O") {
                dmsg("responding to 'O' click to return to full-scale\n")
                state$visible <- rep(TRUE, state$ndata)
            } else if (key == "j") {
                dmsg("responding to 'j' click for moving down in water column\n")
                if (!tail(state$visible, 1)) {
                    limits <- visibleToLimits(state$visible)
                    span <- diff(limits)
                    limits <- limitsTrim(limits + (2/3)*span, state$ndata)
                    state$visible <- limitsToVisible(limits, state$ndata)
                }
            } else if (key == "k") {
                dmsg("responding to 'k' click for moving up in water column\n")
                if (!head(state$visible, 1)) {
                    limits <- visibleToLimits(state$visible)
                    span <- diff(limits)
                    limits <- limitsTrim(limits - (2/3)*span, state$ndata)
                    state$visible <- limitsToVisible(limits, state$ndata)
                }
            } else if (key == "x") {
                dmsg("responding to 'x' to remove tag if focussed\n")
                if (focusIsTagged()) {
                    removeTag(file=state$file, level=state$level, dbname=getDatabaseName())
                    state$step <<- state$step + 1 # other shiny elements notice this
                }
            } else if (key == "u") {
                dmsg("responding to 'u' to remove tag if focussed\n")
                state$level <<- NULL
            }
        })

    observeEvent(input$yProfile, {
        #dmsg("observed input$yProfile=\"", input$yProfile, "\"\n")
        if (input$yProfile == "pressure") {
            data$yProfile <<- data$pressure
            data$ylabProfile <<- resizableLabel("p")
        } else {
            data$yProfile <<- data$sigmaTheta
            data$ylabProfile <<- expression(sigma[theta]* " ["* kg/m^3*"]")
        }
    })

    output$levelMsg <- renderText(
        {
            #if (!is.null(input$hover$x)) {
            #    if (input$view == "T profile") {
            #        sprintf("T=%.3f degC, p=%.3f dbar\n", input$hover$x, input$hover$y)
            #    } else if (input$view == "S profile") {
            #        sprintf("S=%.3f, p=%.3f dbar\n", input$hover$x, input$hover$y)
            #    } else if (input$view == "TS") {
            #        sprintf("S=%.3g C, T=%.3f\n", input$hover$x, input$hover$y)
            #    } else if (input$view == "N(z)") {
            #        sprintf("N=%.3g, p=%.3f dbar\n", input$hover$x, input$hover$y)
            #    } else {
            #        "FIXME"
            #    }
            #} else {
            pvisible <- data$pressure[state$visible]
            sprintf("%.1f to %.1f dbar shown", min(pvisible), max(pvisible))
            #}
        })

    output$tagMsg <- renderText(
        {
            state$step # to cause shiny to update this
            file <- state$file
            tags <- getTags(state$file)
            tags <- tags[tags$file == file, ]
            tagMsg <- if (length(tags$tag) > 0L) {
                pluralize(length(tags$tag), "tag")
            } else {
                "no tags yet"
            }
            focusMsg <- if (focusIsTagged()) paste0(" (focus, at level ", state$level, ", is tagged)") else ""
            paste0(file, ": ", tagMsg, focusMsg)
        })

    output$plotPanel <- renderUI({
        state$step # cause a shiny update
        plotOutput("plot",
            brush=brushOpts("brush", delay=1000, resetOnNew=TRUE),
            hover="hover",
            click="click")
    })

    output$plot <- renderPlot({
        state$step # cause a shiny update
        input$yProfile # cause a shiny update
        if (input$view == "T profile") {
            par(mar=c(1, 3.3, 3, 1), mgp=c(1.9, 0.5, 0))
            x <- state$data$theta[state$visible]
            y <- data$yProfile[state$visible]
            plot(x, y, ylim=rev(range(y)), yaxs="i", type=input$plotType,
                cex=default$Tprofile$cex, col=default$Tprofile$col, lwd=default$Tprofile$lwd, pch=default$Tprofile$pch,
                axes=FALSE, xlab="", ylab="")
            state$usr <<- par("usr")
            if (!is.null(state$level)) {
                with(default$focus,
                    points(state$data$theta[state$level], state$data$yProfile[state$level],
                        cex=cex, col=col, lwd=lwd, pch=pch))
            }
            tags <- getTags(state$file)
            if (length(tags$tag) > 0) {
                with(default$tag,
                    points(state$data$theta[tags$level], state$data$yProfile[tags$level],
                        cex=cex, pch=pch, lwd=lwd, col=1+tags$tag))
            }
            axis(side=2)
            axis(side=3)
            mtext(data$ylab, side=2, line=1.5)
            mtext(resizableLabel("theta"), side=3, line=1.5)
            box()
        } else if (input$view == "S profile") {
            par(mar=c(1, 3, 3, 1), mgp=c(1.9, 0.5, 0))
            x <- state$data$salinity[state$visible]
            y <- state$data$yProfile[state$visible]
            plot(x, y, ylim=rev(range(y)), yaxs="i", type=input$plotType,
                cex=default$Sprofile$cex, col=default$Sprofile$col, lwd=default$Sprofile$lwd, pch=default$Sprofile$pch,
                axes=FALSE, xlab="", ylab="")
            state$usr <<- par("usr")
            if (!is.null(state$level)) {
                dmsg("S profile... ", vectorShow(state$level))
                with(default$focus,
                    points(state$data$salinity[state$level], state$data$yProfile[state$level],
                        cex=cex, col=col, lwd=lwd, pch=pch))
            }
            tags <- getTags(state$file)
            if (length(tags$tag) > 0) {
                with(default$tag,
                    points(state$data$salinity[tags$level], state$data$yProfile[tags$level],
                        cex=cex, pch=pch, lwd=lwd, col=1+tags$tag))
            }
            axis(side=2)
            axis(side=3)
            mtext(data$ylab, side=2, line=1.5)
            mtext(resizableLabel("S"), side=3, line=1.5)
            box()
        } else if (input$view == "TS") {
            par(mar=c(1, 3, 3, 1), mgp=c(1.9, 0.5, 0))
            x <- state$data$salinity[state$visible]
            y <- state$data$temperature[state$visible]
            p <- state$data$pressure[state$visible]
            ctd <- as.ctd(x, y, p)
            # Plot empty with visible data, but then add the actual full data.
            # That way, we can see tagged points even if they are in the 4%
            # within-plot buffer zone.  (I am not using xaxs="i" etc because
            # it can put intrusions on the axis.)
            plotTS(ctd, eos="unesco", type="n")
            points(state$data$salinity, state$data$theta, type=input$plotType,
                cex=default$TS$cex, col=default$TS$col, lwd=default$TS$lwd, pch=default$TS$pch)
            state$usr <<- par("usr")
            if (!is.null(state$level)) {
                with(default$focus,
                    points(state$data$salinity[state$level], state$data$theta[state$level],
                        cex=cex, col=col, lwd=lwd, pch=pch))
            }
            tags <- getTags(state$file)
            if (length(tags$tag) > 0) {
                with(default$tag,
                    points(state$data$salinity[tags$level], state$data$theta[tags$level],
                        cex=cex, pch=pch, lwd=lwd, col=1+tags$tag))
            }
        } else {
            plot(0:1, 0:1, xlab="", ylab="", axes=FALSE, type="n")
            text(0.5, 0.5, paste("ERROR: plot type", input$view, "not handled yet"))
        }
    }, height=500, pointsize=16)
}
#shinyOptions(file="/Users/kelley/Dropbox/data/arctic/beaufort/2012/d201211_0048.cnv")
shiny::shinyOptions(file="/Users/kelley/Dropbox/data/arctic/beaufort/2012/d201211_0047.cnv")
shinyApp(ui, server)

